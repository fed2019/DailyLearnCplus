<!--
 * @Author: pfzhang
 * @E-mail: zhangpengfei@youibot.com
 * @Date: 2022-03-18 11:58:28
 * @LastEditors: pfzhang
 * @LastEditTime: 2022-03-18 12:13:25
 * @Description: Do not edit
 * @FilePath: /learning/doc/死锁.md
-->

### 一、死锁的产生原因
+ 死锁的产生，是由至少两把锁（两个互斥量）才能产生，过程如下：
> 1. 两个线程A，B,线程A开始执行的时候，该线程先锁金锁(JinLock),然后他去锁银锁(YinLock)
> 2. 出现了上下文切换
> 3. 线程B执行了，这个线程先锁银锁，因为银锁还没被锁住，所以会成功加锁，然后线程B要去锁金锁
> 4. 线程A因为拿不到银锁。流程走不下去(后面的代码虽然有解金锁，但是流程走不下去，金锁解不开)
> 5. 线程B因为拿不到金锁，流程走不下去（后面代码有解银锁，但是流程走不下去，所以银锁解不开）

### 二、死锁的解决办法
+ 一般解决办法：
> 使两个互斥量上锁顺序一致，就不会死锁
+ 使用std::lock()函数模板，说明如下：
> 1. 用来处理多个互斥量时才出场,一次锁住两个或者两个以上的互斥量（至少两个，多了不限，1个不行）
> 2. 如果互斥量中有一个没锁住，那他就在那里等着，等所有互斥量都锁住，他才能往下走
> 3. 要么两个互斥量都锁住，要么两个互斥量都没锁住。如果只锁住一个，另一个没锁住，则他立即把已经锁住的解锁。
+ std::lock_guard()的std::adopt_lock参数
> std::adopt_lock是个结构体对象，起一个标记作用，作用就是表示这个互斥量已经lock(),不需要在std::lock_guard\<std::mutex>里面对对象进行再次lock()了
